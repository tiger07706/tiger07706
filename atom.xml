<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>迷途小学生</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://tiger07706.github.io/"/>
  <updated>2018-11-06T07:42:08.844Z</updated>
  <id>http://tiger07706.github.io/</id>
  
  <author>
    <name>tiger07706</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Leetcode练习-164. Maximum Gap</title>
    <link href="http://tiger07706.github.io/2018/11/06/Leetcode%E7%BB%83%E4%B9%A0-164-Maximum-Gap/"/>
    <id>http://tiger07706.github.io/2018/11/06/Leetcode练习-164-Maximum-Gap/</id>
    <published>2018-11-06T06:09:41.000Z</published>
    <updated>2018-11-06T07:42:08.844Z</updated>
    
    <content type="html"><![CDATA[<h2 id="164-最大间距"><a href="#164-最大间距" class="headerlink" title="164. 最大间距"></a>164. 最大间距</h2><p>给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。<br>如果数组元素个数小于 2，则返回 0。</p><p><strong>示例 1</strong><br>输入: [3,6,9,1]<br>输出: 3<br>解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。<br><strong>示例 2</strong><br>输入: [10]<br>输出: 0<br>解释: 数组元素个数小于 2，因此返回 0。<br><strong>说明</strong></p><ul><li>你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。</li><li>请尝试在<strong>线性时间复杂度</strong>和空间复杂度的条件下解决此问题。   </li></ul><p><a href="https://leetcode-cn.com/problems/maximum-gap/description/" target="_blank" rel="noopener">题目链接：https://leetcode-cn.com/problems/maximum-gap/description/</a>   </p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这道题难是<strong>难在要求在O(n)的时间复杂度内完成</strong>，那么肯定不能用常规的排序方式来实现。<br>折腾了好一会，总算写出了pass的方案，基本思路如下：<br>1、采用桶排序的思想，将N个数据划分成为n个桶：<br>比如题中示例1，[3,6,9,1],所有数据都落在[1,9]区间内，于是将该区间划分成为n个桶(实际写的时候划分成为n+1个桶),分别是：<br>0号桶  [1,3)<br>1号桶  [3,5)<br>2号桶  [5,7)<br>3号桶  [7,9]<br>于是对于每个元素a<sub>i</sub>与桶坐标的映射关系是这样的，桶坐标 j = (a<sub>i</sub>-min)/step，其中step是桶的大小，示例1中step=2；<br>2、然后分别计算两个桶之间的距离。<br>3、存储到桶的时候并不需要真正存储所有数据，只需要距离最大值（桶底）和最小值（桶顶）即可，这样存入和读取统数据都可以达到O(1)。<br>最终pass的代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public int maximumGap(int[] nums) &#123;</span><br><span class="line">  if (nums.length &lt; 2)</span><br><span class="line">    return 0;</span><br><span class="line">  int max = nums[0];</span><br><span class="line">  int min = nums[0];</span><br><span class="line">  // 找到最大值和最小值作为桶的区间</span><br><span class="line">  for (int i = 1; i &lt; nums.length; ++i) &#123;</span><br><span class="line">    if (max &lt; nums[i])</span><br><span class="line">      max = nums[i];</span><br><span class="line">    if (min &gt; nums[i])</span><br><span class="line">      min = nums[i];</span><br><span class="line">  &#125;</span><br><span class="line">  if (max == min)</span><br><span class="line">    return 0;</span><br><span class="line">  int n = nums.length;</span><br><span class="line">  double step = (max - min)*0.1 / n;</span><br><span class="line">  BucketNode[] bucket = new BucketNode[n + 1];</span><br><span class="line">  for (int i = 0; i &lt;= n; ++i) &#123;</span><br><span class="line">    bucket[i] = new BucketNode();</span><br><span class="line">  &#125;</span><br><span class="line">  //放到桶里，桶实际只保存了桶底和桶顶</span><br><span class="line">  for (int i = 0; i &lt; n; ++i) &#123;</span><br><span class="line">    int j = (int) ((nums[i] - min) *0.1/ step);</span><br><span class="line">    insertNums(bucket[j], nums[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  int gap = 0;</span><br><span class="line">  int lastBucket = bucket[0].max;</span><br><span class="line">  for (int j = 1; j &lt;= n; ++j) &#123;</span><br><span class="line">    if (!bucket[j].isEmpty) &#123;</span><br><span class="line">      int tempGap = bucket[j].min - lastBucket;</span><br><span class="line">      gap = gap &gt; tempGap ? gap : tempGap;</span><br><span class="line">      // 桶底元素</span><br><span class="line">      lastBucket = bucket[j].max;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return gap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void insertNums(BucketNode bucket, int num) &#123;</span><br><span class="line">  bucket.isEmpty = false;</span><br><span class="line">  bucket.max = bucket.max &gt; num ? bucket.max : num;</span><br><span class="line">  bucket.min = bucket.min &gt; num ? num : bucket.min;</span><br><span class="line">&#125;</span><br><span class="line">public static class BucketNode &#123;</span><br><span class="line">  int min = Integer.MAX_VALUE;</span><br><span class="line">  int max = Integer.MIN_VALUE;</span><br><span class="line">  boolean isEmpty = true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;164-最大间距&quot;&gt;&lt;a href=&quot;#164-最大间距&quot; class=&quot;headerlink&quot; title=&quot;164. 最大间距&quot;&gt;&lt;/a&gt;164. 最大间距&lt;/h2&gt;&lt;p&gt;给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。&lt;br&gt;如果数组元素个数
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-707.Design Linked List</title>
    <link href="http://tiger07706.github.io/2018/11/05/Leetcode%E7%BB%83%E4%B9%A0-707-Design-Linked-List/"/>
    <id>http://tiger07706.github.io/2018/11/05/Leetcode练习-707-Design-Linked-List/</id>
    <published>2018-11-05T09:13:16.000Z</published>
    <updated>2018-11-05T09:26:07.858Z</updated>
    
    <content type="html"><![CDATA[<h2 id="707-设计链表"><a href="#707-设计链表" class="headerlink" title="707. 设计链表"></a>707. 设计链表</h2><p>设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。</p><p>在链表类中实现这些功能：</p><ul><li>get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。</li><li>addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。</li><li>addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。</li><li>addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val  的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。</li><li>deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。</li></ul><p><strong>示例</strong><br>MyLinkedList linkedList = new MyLinkedList();<br>linkedList.addAtHead(1);<br>linkedList.addAtTail(3);<br>linkedList.addAtIndex(1,2);   //链表变为1-&gt; 2-&gt; 3<br>linkedList.get(1);            //返回2<br>linkedList.deleteAtIndex(1);  //现在链表是1-&gt; 3<br>linkedList.get(1);            //返回3    </p><p><a href="https://leetcode-cn.com/problems/design-linked-list/description/" target="_blank" rel="noopener">题目链接：https://leetcode-cn.com/problems/design-linked-list/description/</a>   </p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>链表的基本练习，虽然写的不好，也贴上来吧。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line">public class MyLinkedList &#123;</span><br><span class="line">private LinkedListNode head;</span><br><span class="line">private int len;</span><br><span class="line"></span><br><span class="line">private static class LinkedListNode &#123;</span><br><span class="line">int val;</span><br><span class="line">LinkedListNode next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">  /** Initialize your data structure here. */</span><br><span class="line">public MyLinkedList() &#123;</span><br><span class="line">head = new LinkedListNode();</span><br><span class="line">head.val = -1;</span><br><span class="line">head.next = null;</span><br><span class="line">len = -1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int length() &#123;</span><br><span class="line">return len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Get the value of the index-th node in the linked list. If the index is</span><br><span class="line"> * invalid, return -1.</span><br><span class="line"> */</span><br><span class="line">public int get(int index) &#123;</span><br><span class="line">if (index &gt; len)</span><br><span class="line">return -1;</span><br><span class="line">int i = 0;</span><br><span class="line">LinkedListNode pList = head.next;</span><br><span class="line">while (i &lt; index &amp;&amp; pList != null) &#123;</span><br><span class="line">i++;</span><br><span class="line">pList = pList.next;</span><br><span class="line">&#125;</span><br><span class="line">return pList.val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add a node of value val before the first element of the linked list.</span><br><span class="line"> * After the insertion, the new node will be the first node of the linked</span><br><span class="line"> * list.</span><br><span class="line"> */</span><br><span class="line">public void addAtHead(int val) &#123;</span><br><span class="line">LinkedListNode newNode = new LinkedListNode();</span><br><span class="line">newNode.val = val;</span><br><span class="line">newNode.next = head.next;</span><br><span class="line">head.next = newNode;</span><br><span class="line">++len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Append a node of value val to the last element of the linked list. */</span><br><span class="line">public void addAtTail(int val) &#123;</span><br><span class="line">LinkedListNode pList = head;</span><br><span class="line">while (pList.next != null) &#123;</span><br><span class="line">pList = pList.next;</span><br><span class="line">&#125;</span><br><span class="line">LinkedListNode newNode = new LinkedListNode();</span><br><span class="line">newNode.val = val;</span><br><span class="line">newNode.next = null;</span><br><span class="line">pList.next = newNode;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Add a node of value val before the index-th node in the linked list. If</span><br><span class="line"> * index equals to the length of linked list, the node will be appended to</span><br><span class="line"> * the end of linked list. If index is greater than the length, the node</span><br><span class="line"> * will not be inserted.</span><br><span class="line"> */</span><br><span class="line">public void addAtIndex(int index, int val) &#123;</span><br><span class="line">if (index &gt; len+1)</span><br><span class="line">return;</span><br><span class="line">int count = -1;</span><br><span class="line">LinkedListNode pList = head;</span><br><span class="line">while (pList.next != null) &#123;</span><br><span class="line">if (count == index - 1)</span><br><span class="line">break;</span><br><span class="line">count++;</span><br><span class="line">pList = pList.next;</span><br><span class="line">&#125;</span><br><span class="line">LinkedListNode newNode = new LinkedListNode();</span><br><span class="line">newNode.val = val;</span><br><span class="line">LinkedListNode temp = pList.next;</span><br><span class="line">pList.next = newNode;</span><br><span class="line">newNode.next = temp;</span><br><span class="line">len++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Delete the index-th node in the linked list, if the index is valid. */</span><br><span class="line">public void deleteAtIndex(int index) &#123;</span><br><span class="line">if (index &gt; len)</span><br><span class="line">return;</span><br><span class="line">int count = -1;</span><br><span class="line">LinkedListNode pList = head;</span><br><span class="line">while(pList.next!=null)&#123;</span><br><span class="line">if (count == index - 1)</span><br><span class="line">break;</span><br><span class="line">count++;</span><br><span class="line">pList = pList.next;</span><br><span class="line">&#125;</span><br><span class="line">pList.next = pList.next.next;</span><br><span class="line">len--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;707-设计链表&quot;&gt;&lt;a href=&quot;#707-设计链表&quot; class=&quot;headerlink&quot; title=&quot;707. 设计链表&quot;&gt;&lt;/a&gt;707. 设计链表&lt;/h2&gt;&lt;p&gt;设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-567.Permutation in String</title>
    <link href="http://tiger07706.github.io/2018/11/05/Leetcode%E7%BB%83%E4%B9%A0-567-Permutation-in-String/"/>
    <id>http://tiger07706.github.io/2018/11/05/Leetcode练习-567-Permutation-in-String/</id>
    <published>2018-11-05T07:15:51.000Z</published>
    <updated>2018-11-05T07:47:34.714Z</updated>
    
    <content type="html"><![CDATA[<h2 id="567-字符串的排列"><a href="#567-字符串的排列" class="headerlink" title="567. 字符串的排列"></a>567. 字符串的排列</h2><p>给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。<br>换句话说，第一个字符串的排列之一是第二个字符串的子串。    </p><p><strong>示例1</strong><br>输入: s1 = “ab” s2 = “eidbaooo”<br>输出: True<br>解释: s2 包含 s1 的排列之一 (“ba”).<br><strong>示例2</strong><br>输入: s1 = “abc” s2 = “bbbca”<br>输出: True  </p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>1、这是简单的滑窗问题，可以假想一个长度为s1.length的滑窗，从左到右进行扫描；<br>2、为了简化问题，只有遇到滑窗内是累加之和等于s1的累加之和才进下一步的判断；<br>3、题目标明，输入字符只包含小写字母，于是可用长度为26的数组标记是否访问，也不做非法字符判断了。<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public boolean checkInclusion(String s1, String s2) &#123;</span><br><span class="line">  if (s2.length() &lt; s1.length())</span><br><span class="line">    return false;</span><br><span class="line"></span><br><span class="line">  int target = 0;</span><br><span class="line">  for (int i = 0; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">    target += s1.charAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  int slideWidth = s1.length();</span><br><span class="line">  int sumWindow = 0;</span><br><span class="line">  for (int i = 0; i &lt; slideWidth-1; ++i) &#123;</span><br><span class="line">    sumWindow += s2.charAt(i);</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = slideWidth - 1; i &lt; s2.length(); i++) &#123;</span><br><span class="line">    sumWindow +=s2.charAt(i);</span><br><span class="line">    if (sumWindow == target) &#123;</span><br><span class="line">      // 确认是否对的</span><br><span class="line">      if(compareStr(s1, s2.substring(i - slideWidth + 1, i + 1)))</span><br><span class="line">        return true;</span><br><span class="line">      sumWindow -= s2.charAt(i - slideWidth + 1);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      sumWindow -= s2.charAt(i - slideWidth + 1);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line">private boolean compareStr(String s1, String s2) &#123;</span><br><span class="line">  boolean flag = true;</span><br><span class="line">  int[] visited = new int[26];</span><br><span class="line">  for (int i = 0; i &lt; s1.length(); ++i) &#123;</span><br><span class="line">    visited[s1.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; s2.length(); ++i) &#123;</span><br><span class="line">    visited[s2.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">  &#125;</span><br><span class="line">  for (int i = 0; i &lt; 26; i++) &#123;</span><br><span class="line">    if (visited[i] % 2 != 0) &#123;</span><br><span class="line">      flag = false;</span><br><span class="line">      break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;567-字符串的排列&quot;&gt;&lt;a href=&quot;#567-字符串的排列&quot; class=&quot;headerlink&quot; title=&quot;567. 字符串的排列&quot;&gt;&lt;/a&gt;567. 字符串的排列&lt;/h2&gt;&lt;p&gt;给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-14.Longest Common Prefix</title>
    <link href="http://tiger07706.github.io/2018/11/05/Leetcode%E7%BB%83%E4%B9%A0-14-Longest-Common-Prefix/"/>
    <id>http://tiger07706.github.io/2018/11/05/Leetcode练习-14-Longest-Common-Prefix/</id>
    <published>2018-11-05T02:46:49.000Z</published>
    <updated>2018-11-05T07:47:21.842Z</updated>
    
    <content type="html"><![CDATA[<h2 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a>14. 最长公共前缀</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。<br>如果不存在公共前缀，返回空字符串 “”。   </p><p><strong>示例1</strong><br>输入: [“flower”,”flow”,”flight”]<br>输出: “fl”<br><a href="https://leetcode.com/problems/longest-common-prefix/description/" target="_blank" rel="noopener">题目链接：https://leetcode.com/problems/longest-common-prefix/description/</a><br>题目难度：easy   </p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>直接搜索就可以了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">  if (null == strs || strs.length &lt;= 0) &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (strs.length == 1)</span><br><span class="line">    return strs[0];</span><br><span class="line">  int len = strs[0].length();</span><br><span class="line">  for (int i = 1; i &lt; strs.length; ++i) &#123;</span><br><span class="line">    int iCount = 0;</span><br><span class="line">    for (int j = 0; j &lt; strs[i].length() &amp;&amp; j &lt; strs[0].length(); ++j) &#123;</span><br><span class="line">      if (strs[0].charAt(j) == strs[i].charAt(j)) &#123;</span><br><span class="line">        iCount++;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">      // 比当前的前缀长，可以不用继续遍历了</span><br><span class="line">      if (iCount &gt; len) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (len &gt; iCount) &#123;</span><br><span class="line">      len = iCount;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return strs[0].substring(0, len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;14-最长公共前缀&quot;&gt;&lt;a href=&quot;#14-最长公共前缀&quot; class=&quot;headerlink&quot; title=&quot;14. 最长公共前缀&quot;&gt;&lt;/a&gt;14. 最长公共前缀&lt;/h2&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;br&gt;如果不存在公共前缀，返回空
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-463. Island Perimeter</title>
    <link href="http://tiger07706.github.io/2018/11/02/Leetcode%E7%BB%83%E4%B9%A0-463-Island-Perimeter/"/>
    <id>http://tiger07706.github.io/2018/11/02/Leetcode练习-463-Island-Perimeter/</id>
    <published>2018-11-02T09:41:59.000Z</published>
    <updated>2018-11-05T07:47:19.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="463-岛屿的周长"><a href="#463-岛屿的周长" class="headerlink" title="463. 岛屿的周长"></a>463. 岛屿的周长</h2><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。<br>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。<br>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。     </p><p><strong>示例</strong><br>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]<br> 解释: 它的周长是下面图片中的 16 个黄色的边：<br> <img src="/2018/11/02/Leetcode练习-463-Island-Perimeter/./island.png" alt=""><br> <a href="https://leetcode-cn.com/problems/island-perimeter/description/" target="_blank" rel="noopener">题目链接:https://leetcode-cn.com/problems/island-perimeter/description/</a></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>虽然这道题是easy级别的,但是我发现它有个挺有意思的规律，那就是每读到一个标记为1的格子，它贡献的周长的计算应该是：<br><strong> 4-sum(上下左右格子之和)  </strong><br>于是只要把这个矩阵读完就可以了，好吧，我先试验一下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int islandPerimeter(int[][] grid) &#123;</span><br><span class="line">  int result = 0;</span><br><span class="line">  for (int i = 0; i &lt; grid.length; i++) &#123;</span><br><span class="line">    for (int j = 0; j &lt; grid[i].length; j++) &#123;</span><br><span class="line">      if (grid[i][j] == 1) &#123;</span><br><span class="line">        int x = 4;</span><br><span class="line">        if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1)</span><br><span class="line">          x -= 1;</span><br><span class="line">        if (i + 1 &lt; grid.length &amp;&amp; grid[i + 1][j] == 1)</span><br><span class="line">          x -= 1;</span><br><span class="line">        if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1)</span><br><span class="line">          x -= 1;</span><br><span class="line">        if (j + 1 &lt; grid[i].length &amp;&amp; grid[i][j + 1] == 1)</span><br><span class="line">          x -= 1;</span><br><span class="line">        result += x;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>提交，pass,一坨屎写法，但是pass，以后再回来看怎么优化吧.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;463-岛屿的周长&quot;&gt;&lt;a href=&quot;#463-岛屿的周长&quot; class=&quot;headerlink&quot; title=&quot;463. 岛屿的周长&quot;&gt;&lt;/a&gt;463. 岛屿的周长&lt;/h2&gt;&lt;p&gt;给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。&lt;b
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-746.Min Cost Climbing Stairs</title>
    <link href="http://tiger07706.github.io/2018/11/01/Leetcode%E7%BB%83%E4%B9%A0-746-Min-Cost-Climbing-Stairs/"/>
    <id>http://tiger07706.github.io/2018/11/01/Leetcode练习-746-Min-Cost-Climbing-Stairs/</id>
    <published>2018-11-01T09:27:48.000Z</published>
    <updated>2018-11-05T07:48:30.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="746-使用最小花费爬楼梯"><a href="#746-使用最小花费爬楼梯" class="headerlink" title="746. 使用最小花费爬楼梯"></a>746. 使用最小花费爬楼梯</h2><p>数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost<a href="索引从0开始">i</a>。<br>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。<br>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。     </p><p><strong>示例</strong><br>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</p><p>注意：<br>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。<br><a href="https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/</a></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>这是经典的动态规划题目，每次动作可以选择爬一个阶梯或者两个阶梯，而总体花费最小的走法应该是<br>（走一步的开销）+（走剩下的路的最小开销） 和（走两步的开销）+（走剩下的路的最小开销）之间的较小值。<br>这样说太费劲了，写成公式是这样的：<br><strong> dp[k] = Math.min(cost[i-1]+dp[k-1],cost[i]+dp[k-2]) </strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int minCostClimbingStairs(int[] cost) &#123;</span><br><span class="line">  // 可以直接到达</span><br><span class="line">  if (cost.length &lt;= 1)</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">  int dp0 = 0, dp1 = 0, dp2 = 0;</span><br><span class="line">  for (int i = 1; i &lt; cost.length; i++) &#123;</span><br><span class="line">    if (cost[i] == cost[i - 1]) &#123;</span><br><span class="line">      dp0 = cost[i - 1] + dp1;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      dp0 = (dp2 + cost[i]) &gt;= (dp1 + cost[i - 1]) ? (dp1 + cost[i - 1])</span><br><span class="line">          : (dp2 + cost[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dp1 = dp2;</span><br><span class="line">    dp2 = dp0;</span><br><span class="line">  &#125;</span><br><span class="line">  return dp0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;746-使用最小花费爬楼梯&quot;&gt;&lt;a href=&quot;#746-使用最小花费爬楼梯&quot; class=&quot;headerlink&quot; title=&quot;746. 使用最小花费爬楼梯&quot;&gt;&lt;/a&gt;746. 使用最小花费爬楼梯&lt;/h2&gt;&lt;p&gt;数组的每个索引做为一个阶梯，第 i个阶梯对应着一
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
      <category term="动态规划" scheme="http://tiger07706.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-662.Maximum Width of Binary Tree</title>
    <link href="http://tiger07706.github.io/2018/11/01/Leetcode%E7%BB%83%E4%B9%A0-662-Maximum-Width-of-Binary-Tree/"/>
    <id>http://tiger07706.github.io/2018/11/01/Leetcode练习-662-Maximum-Width-of-Binary-Tree/</id>
    <published>2018-11-01T06:35:17.000Z</published>
    <updated>2018-11-05T07:47:04.457Z</updated>
    
    <content type="html"><![CDATA[<h2 id="662-二叉树最大宽度"><a href="#662-二叉树最大宽度" class="headerlink" title="662. 二叉树最大宽度"></a>662. 二叉树最大宽度</h2><p>给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。</p><p>每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。<br><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree/description/" target="_blank" rel="noopener">题目链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/description/</a></p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>这道题我开始想错了，我开始以为是：一个二叉树的最大宽度应该是左右两颗子树各自的最大宽度之和。<br>然而不是的，看了题目示例，是按照每一层来计算的，如下所示：<br>输入:</p><pre><code>    1   / \  3   2 /        5      </code></pre><p>输出: 2<br>解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。<br>并不是我所想的，最大宽度是节点5和节点2的距离。<br>这样有个暴力点的解法，将二叉树按照满二叉树树一样存储到数组里面，就可以计算到每一层的距离了。当然我们不需要真正存储这些节点，只需要计算出它在数组中的位置就可以了。<br>一颗满二叉树第k层有多少个节点：2^(k-1)<br>一颗满二叉树总的节点数：2^k - 1<br>额，背错公式了，关键应该是：<br><strong>  如果满二叉树的某一节点在数组中的坐标为i，那么左右孩子是2<em>i-1和2</em>i  </strong></p><p>中途偷偷看了答案，发现其中一个答案跟我的思路是一样的，折腾了半天，最后通过的代码是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public int widthOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">  int maxWidth = -1;</span><br><span class="line">  if (null == root)</span><br><span class="line">    return 0;</span><br><span class="line">  Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">  Queue&lt;Integer&gt; indexQueue = new LinkedList&lt;&gt;();</span><br><span class="line">  queue.offer(root);</span><br><span class="line">  indexQueue.offer(1);</span><br><span class="line">  while (!queue.isEmpty()) &#123;</span><br><span class="line">    int minIndex = Integer.MAX_VALUE;</span><br><span class="line">    int maxIndex = -1;</span><br><span class="line">    int len = queue.size();</span><br><span class="line">    for (int i = 0; i &lt; len; ++i) &#123;</span><br><span class="line">      // 两个队列出队入队要保持一致</span><br><span class="line">      TreeNode pNode = queue.poll();</span><br><span class="line">      int index = indexQueue.poll();</span><br><span class="line">      minIndex = minIndex &gt; index ? index : minIndex;</span><br><span class="line">      maxIndex = maxIndex &gt; index ? maxIndex : index;</span><br><span class="line">      if (null != pNode.left) &#123;</span><br><span class="line">        queue.offer(pNode.left);</span><br><span class="line">        indexQueue.offer(2 * index - 1);</span><br><span class="line">      &#125;</span><br><span class="line">      if (null != pNode.right) &#123;</span><br><span class="line">        queue.offer(pNode.right);</span><br><span class="line">        indexQueue.offer(2 * index);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    maxWidth = maxWidth &gt; (maxIndex - minIndex + 1) ? maxWidth</span><br><span class="line">        : (maxIndex - minIndex + 1);</span><br><span class="line">  &#125;</span><br><span class="line">  return maxWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;662-二叉树最大宽度&quot;&gt;&lt;a href=&quot;#662-二叉树最大宽度&quot; class=&quot;headerlink&quot; title=&quot;662. 二叉树最大宽度&quot;&gt;&lt;/a&gt;662. 二叉树最大宽度&lt;/h2&gt;&lt;p&gt;给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-27.Remove Element</title>
    <link href="http://tiger07706.github.io/2018/11/01/Leetcode%E7%BB%83%E4%B9%A0-27-Remove-Element/"/>
    <id>http://tiger07706.github.io/2018/11/01/Leetcode练习-27-Remove-Element/</id>
    <published>2018-11-01T06:16:25.000Z</published>
    <updated>2018-11-05T07:47:23.329Z</updated>
    
    <content type="html"><![CDATA[<h2 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h2><p>给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。<br><a href="https://leetcode-cn.com/problems/remove-element/description/" target="_blank" rel="noopener">题目连接:https://leetcode-cn.com/problems/remove-element/description/</a></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>使用快慢指针进行遍历，慢指针跳过等于val的值，提交-&gt;pass，下一题。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line"> int low = 0, high = 0;</span><br><span class="line"> while (low &lt; nums.length) &#123;</span><br><span class="line">  if (val != nums[low]) &#123;</span><br><span class="line">    nums[high++] = nums[low++];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    ++low;</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> return high;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;27-移除元素&quot;&gt;&lt;a href=&quot;#27-移除元素&quot; class=&quot;headerlink&quot; title=&quot;27. 移除元素&quot;&gt;&lt;/a&gt;27. 移除元素&lt;/h2&gt;&lt;p&gt;给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-42.Trapping Rain Water</title>
    <link href="http://tiger07706.github.io/2018/11/01/Leetcode%E7%BB%83%E4%B9%A0-42-Trapping-Rain-Water/"/>
    <id>http://tiger07706.github.io/2018/11/01/Leetcode练习-42-Trapping-Rain-Water/</id>
    <published>2018-11-01T03:42:36.000Z</published>
    <updated>2018-11-01T06:34:28.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a>42. 接雨水</h2><p>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。<br><img src="/2018/11/01/Leetcode练习-42-Trapping-Rain-Water/./rainwatertrap.png" alt=""><br>上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。<br>示例:   </p><blockquote><p>输入: [0,1,0,2,1,0,1,3,2,1,2,1]<br>输出: 6      </p></blockquote><p><a href="https://leetcode-cn.com/problems/trapping-rain-water/description/" target="_blank" rel="noopener">题目连接:https://leetcode-cn.com/problems/trapping-rain-water/description/</a></p><p>初步思路：<br>木桶的的储水量取决于最短板，那么从左到右扫描，遇到第一个比它高的柱子，然后可以计算这两个柱子之间的储水量。<br>怎么计算中间的储水量：可以观察到底部宽都是1，那就是两个柱子间的矩形面积减去中间柱子的累加之和。<br>这样还有一个问题是，扫描到最高柱子后，就开始“走下坡”了，这时最短板在更高的位置。<br>ok，现在去试验一下，下面列出一坨屎的写法，这是最原始的想法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 42. Trapping Rain Water</span><br><span class="line"> *</span><br><span class="line"> * @param height</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">public int trap(int[] height) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int low = 0, high = 0;</span><br><span class="line">  int minIndex = getMaxIndex(height);</span><br><span class="line">  //正序遍历，计算储水量</span><br><span class="line">  while (low &lt; minIndex) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    high = low + 1;</span><br><span class="line">    while (high &lt; minIndex) &#123;</span><br><span class="line">      if (height[low] &gt; height[high])&#123;</span><br><span class="line">        temp += height[high];</span><br><span class="line">        ++high;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += height[low] * (high - low -1) - temp;</span><br><span class="line">    low = high;</span><br><span class="line">  &#125;</span><br><span class="line">  //反向遍历</span><br><span class="line">  high = height.length-1;</span><br><span class="line">  while (high &gt;= minIndex) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    low = high - 1;</span><br><span class="line">    while (low &gt;= minIndex) &#123;</span><br><span class="line">      if (height[high] &gt; height[low])&#123;</span><br><span class="line">        temp += height[low];</span><br><span class="line">        --low;</span><br><span class="line">      &#125;</span><br><span class="line">      else</span><br><span class="line">        break;</span><br><span class="line">    &#125;</span><br><span class="line">    sum += height[high] * (high - low -1) - temp;</span><br><span class="line">    high = low;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @param height</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line">private int getMaxIndex(int[] height) &#123;</span><br><span class="line">  // TODO Auto-generated method stub</span><br><span class="line">  int max = -1;</span><br><span class="line">  int k = 0;</span><br><span class="line">  for(int i = 0;i&lt;height.length;++i)&#123;</span><br><span class="line">    if(max&lt;height[i])&#123;</span><br><span class="line">      max = height[i];</span><br><span class="line">      k = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>按这个思路提交，居然pass了，好吧。<br>当然这一坨shit写法肯定会让很多人放弃阅读了，偷偷看了一下答案，发现答案写的巧妙一些，它是两边向中间收缩，慢慢计算，不过我觉得我的思路也很明了，暂时就不修改了，以下代码来自九章刷题小工具。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param heights: an array of integers</span><br><span class="line"> * @return: a integer</span><br><span class="line"> */</span><br><span class="line">public int trapRainWater(int[] heights) &#123;</span><br><span class="line">    // write your code here</span><br><span class="line">    int left = 0, right = heights.length - 1;</span><br><span class="line">    int res = 0;</span><br><span class="line">    if(left &gt;= right)</span><br><span class="line">        return res;</span><br><span class="line">    int leftheight = heights[left];</span><br><span class="line">    int rightheight = heights[right];</span><br><span class="line">    while(left &lt; right) &#123;</span><br><span class="line">        if(leftheight &lt; rightheight) &#123;</span><br><span class="line">            left ++;</span><br><span class="line">            if(leftheight &gt; heights[left]) &#123;</span><br><span class="line">                res += (leftheight - heights[left]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                leftheight = heights[left];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            right --;</span><br><span class="line">            if(rightheight &gt; heights[right]) &#123;</span><br><span class="line">                res += (rightheight - heights[right]);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                rightheight = heights[right];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;42-接雨水&quot;&gt;&lt;a href=&quot;#42-接雨水&quot; class=&quot;headerlink&quot; title=&quot;42. 接雨水&quot;&gt;&lt;/a&gt;42. 接雨水&lt;/h2&gt;&lt;p&gt;给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。&lt;br
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode练习-11.Container With Most Water.md</title>
    <link href="http://tiger07706.github.io/2018/10/31/Leetcode%E7%BB%83%E4%B9%A0-11-Container-With-Most-Water-md/"/>
    <id>http://tiger07706.github.io/2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/</id>
    <published>2018-10-31T13:15:15.000Z</published>
    <updated>2018-11-05T07:47:26.557Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a>11. 盛最多水的容器</h2><p>给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。<br>说明：你不能倾斜容器，且 n 的值至少为 2。<br><img src="/2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/question_11.jpg" alt=""><br>图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。      </p><p><strong>示例:</strong><br>输入: [1,8,6,2,5,4,8,3,7]<br>输出: 49<br><a href="https://leetcode-cn.com/problems/container-with-most-water/description/" target="_blank" rel="noopener">题目链接：https://leetcode-cn.com/problems/container-with-most-water/description/</a></p><h3 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h3><p>暴力求解，时间复杂度O(n^2),空间复杂度O(1)</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">  int max = -1;</span><br><span class="line">  for (int i = 0; i &lt; height.length; i++) &#123;</span><br><span class="line">    for (int j = i + 1; j &lt; height.length; j++) &#123;</span><br><span class="line">      int high = height[i] &gt; height[j] ? height[j] : height[i];</span><br><span class="line">      int temp = (j - i) * high;</span><br><span class="line">      max = max &gt; temp ? max : temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 一提交，pass。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-盛最多水的容器&quot;&gt;&lt;a href=&quot;#11-盛最多水的容器&quot; class=&quot;headerlink&quot; title=&quot;11. 盛最多水的容器&quot;&gt;&lt;/a&gt;11. 盛最多水的容器&lt;/h2&gt;&lt;p&gt;给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (
      
    
    </summary>
    
      <category term="Leetcode练习" scheme="http://tiger07706.github.io/categories/Leetcode%E7%BB%83%E4%B9%A0/"/>
    
    
      <category term="Leetcode" scheme="http://tiger07706.github.io/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://tiger07706.github.io/2018/10/18/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://tiger07706.github.io/2018/10/18/排序算法/</id>
    <published>2018-10-18T03:19:28.000Z</published>
    <updated>2018-10-19T09:42:40.015Z</updated>
    
    <content type="html"><![CDATA[<h1 id="十大基本排序算法汇总"><a href="#十大基本排序算法汇总" class="headerlink" title="十大基本排序算法汇总"></a>十大基本排序算法汇总</h1><h2 id="时间复杂度和空间复杂度对比"><a href="#时间复杂度和空间复杂度对比" class="headerlink" title="时间复杂度和空间复杂度对比"></a>时间复杂度和空间复杂度对比</h2><table><thead><tr><th>排序算法</th><th style="text-align:right">时间复杂度（平均）</th><th style="text-align:right">时间复杂度（最坏）</th><th style="text-align:right">时间复杂度（最好）</th><th style="text-align:right">空间复杂度</th><th style="text-align:right">稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n)</td><td style="text-align:right">O(1)</td><td style="text-align:right">稳定</td></tr><tr><td>插入排序</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n)</td><td style="text-align:right">O(1)</td><td style="text-align:right">稳定</td></tr><tr><td>归并排序</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(n)</td><td style="text-align:right">稳定</td></tr><tr><td>计数排序</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">稳定</td></tr><tr><td>桶排序</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n)</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">稳定</td></tr><tr><td>基数排序</td><td style="text-align:right">O(n*k)</td><td style="text-align:right">O(n*k)</td><td style="text-align:right">O(n*k)</td><td style="text-align:right">O(n+k)</td><td style="text-align:right">稳定</td></tr><tr><td>希尔排序</td><td style="text-align:right">O(n<sup>1.3</sup>)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n)</td><td style="text-align:right">O(1)</td><td style="text-align:right">不稳定</td></tr><tr><td>选择排序</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(1)</td><td style="text-align:right">不稳定</td></tr><tr><td>堆排序</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(1)</td><td style="text-align:right">不稳定</td></tr><tr><td>快速排序</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(n^2)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">O(nlog<sub>2</sub>n)</td><td style="text-align:right">不稳定</td></tr></tbody></table><h2 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h2><p>可能大部分人第一次接触排序，学的都是冒泡排序，不多说，直接贴代码吧。   </p><h3 id="一个优化的思路：标记位判断是否有序"><a href="#一个优化的思路：标记位判断是否有序" class="headerlink" title="一个优化的思路：标记位判断是否有序"></a>一个优化的思路：标记位判断是否有序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort(int[] arr) &#123;</span><br><span class="line">for (int i = 0, len = arr.length; i &lt; len - 1; i++) &#123;</span><br><span class="line">boolean flag = false; // 标记判断是否有序</span><br><span class="line">for (int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">if (arr[j] &gt; arr[j + 1]) &#123;</span><br><span class="line">swap(arr, j, j + 1);</span><br><span class="line">flag = true;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (!flag)break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了"><a href="#另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了" class="headerlink" title="另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了"></a>另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void BubbleSort2(int[] arr) &#123;</span><br><span class="line">    for (int i = 0, len = arr.length, lastPosition = 0; i &lt; len - 1; i = len - lastPosition - 1) &#123;</span><br><span class="line">        lastPosition = 0;</span><br><span class="line">        for (int j = 0; j &lt; len - i - 1; j++) &#123;</span><br><span class="line">            if (arr[j]&gt;arr[j + 1]) &#123;</span><br><span class="line">                swap(arr, j, j + 1);</span><br><span class="line">                lastPosition = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="延伸：鸡尾酒排序"><a href="#延伸：鸡尾酒排序" class="headerlink" title="延伸：鸡尾酒排序"></a>延伸：鸡尾酒排序</h3><p>鸡尾酒是一种特殊的冒泡排序，先用正向冒泡，把最大的值冒泡到后面，再用反向冒泡把最小值冒泡到数组前面。</p><ul><li>参考阅读：<a href="https://mp.weixin.qq.com/s/XC85OLOZEUNuV2t6M1I3jg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/XC85OLOZEUNuV2t6M1I3jg</a></li></ul><h2 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h2><p>第二个介绍的是快速排序，因为最近参加过一次面试，被问了快速排序，巴拉巴拉的迅速写了个代码，然而关于基准数的选取没答好，好吧下面简单介绍快排以及它的优化方案。</p><blockquote><p>下图是别人做的一个优化方案对比<br><img src="/2018/10/18/排序算法/20180604083804407.jpg" alt="快排优化方案对比"></p></blockquote><p>优化主要是两个思路：一个是优化选取基准数；一个是优化小数组时选取的排序方法。</p><ul><li>选取基准数有两种（或者叫枢轴，可能是普通话不好，我一直喊基准数，/手动狗头）<br>1、随机基准数（略）<br>  2、三数取中法     <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;十大基本排序算法汇总&quot;&gt;&lt;a href=&quot;#十大基本排序算法汇总&quot; class=&quot;headerlink&quot; title=&quot;十大基本排序算法汇总&quot;&gt;&lt;/a&gt;十大基本排序算法汇总&lt;/h1&gt;&lt;h2 id=&quot;时间复杂度和空间复杂度对比&quot;&gt;&lt;a href=&quot;#时间复杂度和空间
      
    
    </summary>
    
      <category term="基础算法" scheme="http://tiger07706.github.io/categories/%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="排序算法" scheme="http://tiger07706.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://tiger07706.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>hexo命令速查（持续补充）</title>
    <link href="http://tiger07706.github.io/2018/10/17/2018-10-17%20hexo%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5/"/>
    <id>http://tiger07706.github.io/2018/10/17/2018-10-17 hexo命令速查/</id>
    <published>2018-10-17T05:59:25.000Z</published>
    <updated>2018-10-19T03:17:01.195Z</updated>
    
    <content type="html"><![CDATA[<h2 id="写作相关的命令"><a href="#写作相关的命令" class="headerlink" title="写作相关的命令"></a>写作相关的命令</h2><h3 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h3><pre><code>$ hexo new [layout] &lt;title&gt;</code></pre><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p><ul><li>布局（Layout）<br>Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。</li></ul><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><p>  $ hexo g -d<br>    $ hexo d -g</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;写作相关的命令&quot;&gt;&lt;a href=&quot;#写作相关的命令&quot; class=&quot;headerlink&quot; title=&quot;写作相关的命令&quot;&gt;&lt;/a&gt;写作相关的命令&lt;/h2&gt;&lt;h3 id=&quot;新建一篇文章&quot;&gt;&lt;a href=&quot;#新建一篇文章&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="hexo" scheme="http://tiger07706.github.io/categories/hexo/"/>
    
    
      <category term="hexo" scheme="http://tiger07706.github.io/tags/hexo/"/>
    
      <category term="命令" scheme="http://tiger07706.github.io/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
</feed>
