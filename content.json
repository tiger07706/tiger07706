{"meta":{"title":"迷途小学生","subtitle":null,"description":null,"author":"tiger07706","url":"http://tiger07706.github.io"},"pages":[{"title":"about","date":"2018-10-17T09:38:45.000Z","updated":"2018-10-18T01:54:13.962Z","comments":false,"path":"about/index.html","permalink":"http://tiger07706.github.io/about/index.html","excerpt":"","text":"联系方式：694594147@qq.com"},{"title":"links","date":"2018-10-17T09:38:24.000Z","updated":"2018-10-17T09:38:24.046Z","comments":true,"path":"links/index.html","permalink":"http://tiger07706.github.io/links/index.html","excerpt":"","text":""},{"title":"books","date":"2018-10-18T02:00:01.000Z","updated":"2018-10-18T02:00:01.641Z","comments":true,"path":"books/index.html","permalink":"http://tiger07706.github.io/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-17T09:27:45.000Z","updated":"2018-10-17T09:45:02.692Z","comments":true,"path":"categories/index.html","permalink":"http://tiger07706.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-18T01:59:45.000Z","updated":"2018-10-18T01:59:45.093Z","comments":true,"path":"tags/index.html","permalink":"http://tiger07706.github.io/tags/index.html","excerpt":"","text":""},{"title":"repository","date":"2018-10-18T02:03:28.000Z","updated":"2018-10-18T02:03:28.663Z","comments":true,"path":"repository/index.html","permalink":"http://tiger07706.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode练习-14.Longest Common Prefix","slug":"Leetcode练习-14-Longest-Common-Prefix","date":"2018-11-05T02:46:49.000Z","updated":"2018-11-05T02:46:49.829Z","comments":true,"path":"2018/11/05/Leetcode练习-14-Longest-Common-Prefix/","link":"","permalink":"http://tiger07706.github.io/2018/11/05/Leetcode练习-14-Longest-Common-Prefix/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Leetcode练习-463. Island Perimeter","slug":"Leetcode练习-463-Island-Perimeter","date":"2018-11-02T09:41:59.000Z","updated":"2018-11-02T09:58:17.040Z","comments":true,"path":"2018/11/02/Leetcode练习-463-Island-Perimeter/","link":"","permalink":"http://tiger07706.github.io/2018/11/02/Leetcode练习-463-Island-Perimeter/","excerpt":"","text":"463. 岛屿的周长给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。 网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。 岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 ###示例 :输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 解释: 它的周长是下面图片中的 16 个黄色的边： 题目链接:https://leetcode-cn.com/problems/island-perimeter/description/ 解答虽然这道题是easy级别的,但是我发现它有个挺有意思的规律，那就是每读到一个标记为1的格子，它贡献的周长的计算应该是： 4-sum(上下左右格子之和) 于是只要把这个矩阵读完就可以了，好吧，我先试验一下：1234567891011121314151617181920public int islandPerimeter(int[][] grid) &#123; int result = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == 1) &#123; int x = 4; if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) x -= 1; if (i + 1 &lt; grid.length &amp;&amp; grid[i + 1][j] == 1) x -= 1; if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1) x -= 1; if (j + 1 &lt; grid[i].length &amp;&amp; grid[i][j + 1] == 1) x -= 1; result += x; &#125; &#125; &#125; return result;&#125; 提交，pass,一坨屎写法，但是pass，以后再回来看怎么优化吧.","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-746.Min Cost Climbing Stairs","slug":"Leetcode练习-746-Min-Cost-Climbing-Stairs","date":"2018-11-01T09:27:48.000Z","updated":"2018-11-02T09:58:19.804Z","comments":true,"path":"2018/11/01/Leetcode练习-746-Min-Cost-Climbing-Stairs/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-746-Min-Cost-Climbing-Stairs/","excerpt":"","text":"746. 使用最小花费爬楼梯数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。示例1： 输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意： cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/ 解答：这是经典的动态规划题目，每次动作可以选择爬一个阶梯或者两个阶梯，而总体花费最小的走法应该是（走一步的开销）+（走剩下的路的最小开销） 和（走两步的开销）+（走剩下的路的最小开销）之间的较小值。这样说太费劲了，写成公式是这样的： dp[k] = Math.min(cost[i-1]+dp[k-1],cost[i]+dp[k-2]) 123456789101112131415161718public int minCostClimbingStairs(int[] cost) &#123; // 可以直接到达 if (cost.length &lt;= 1) return 0; int dp0 = 0, dp1 = 0, dp2 = 0; for (int i = 1; i &lt; cost.length; i++) &#123; if (cost[i] == cost[i - 1]) &#123; dp0 = cost[i - 1] + dp1; &#125; else &#123; dp0 = (dp2 + cost[i]) &gt;= (dp1 + cost[i - 1]) ? (dp1 + cost[i - 1]) : (dp2 + cost[i]); &#125; dp1 = dp2; dp2 = dp0; &#125; return dp0;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://tiger07706.github.io/tags/动态规划/"}]},{"title":"Leetcode练习-662.Maximum Width of Binary Tree","slug":"Leetcode练习-662-Maximum-Width-of-Binary-Tree","date":"2018-11-01T06:35:17.000Z","updated":"2018-11-01T09:00:41.835Z","comments":true,"path":"2018/11/01/Leetcode练习-662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"662. 二叉树最大宽度给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。题目链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/description/ 解题思路：这道题我开始想错了，我开始以为是：一个二叉树的最大宽度应该是左右两颗子树各自的最大宽度之和。然而不是的，看了题目示例，是按照每一层来计算的，如下所示：输入: 1 / \\ 3 2 / 5 输出: 2解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。并不是我所想的，最大宽度是节点5和节点2的距离。这样有个暴力点的解法，将二叉树按照满二叉树树一样存储到数组里面，就可以计算到每一层的距离了。当然我们不需要真正存储这些节点，只需要计算出它在数组中的位置就可以了。一颗满二叉树第k层有多少个节点：2^(k-1)一颗满二叉树总的节点数：2^k - 1额，背错公式了，关键应该是： 如果满二叉树的某一节点在数组中的坐标为i，那么左右孩子是2i-1和2i 中途偷偷看了答案，发现其中一个答案跟我的思路是一样的，折腾了半天，最后通过的代码是这样的：1234567891011121314151617181920212223242526272829303132public int widthOfBinaryTree(TreeNode root) &#123; int maxWidth = -1; if (null == root) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; indexQueue = new LinkedList&lt;&gt;(); queue.offer(root); indexQueue.offer(1); while (!queue.isEmpty()) &#123; int minIndex = Integer.MAX_VALUE; int maxIndex = -1; int len = queue.size(); for (int i = 0; i &lt; len; ++i) &#123; // 两个队列出队入队要保持一致 TreeNode pNode = queue.poll(); int index = indexQueue.poll(); minIndex = minIndex &gt; index ? index : minIndex; maxIndex = maxIndex &gt; index ? maxIndex : index; if (null != pNode.left) &#123; queue.offer(pNode.left); indexQueue.offer(2 * index - 1); &#125; if (null != pNode.right) &#123; queue.offer(pNode.right); indexQueue.offer(2 * index); &#125; &#125; maxWidth = maxWidth &gt; (maxIndex - minIndex + 1) ? maxWidth : (maxIndex - minIndex + 1); &#125; return maxWidth;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-27.Remove Element","slug":"Leetcode练习-27-Remove-Element","date":"2018-11-01T06:16:25.000Z","updated":"2018-11-01T06:16:53.012Z","comments":true,"path":"2018/11/01/Leetcode练习-27-Remove-Element/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-27-Remove-Element/","excerpt":"","text":"27. 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。题目连接:https://leetcode-cn.com/problems/remove-element/description/ 解答：使用快慢指针进行遍历，慢指针跳过等于val的值，提交-&gt;pass，下一题。 1234567891011public int removeElement(int[] nums, int val) &#123; int low = 0, high = 0; while (low &lt; nums.length) &#123; if (val != nums[low]) &#123; nums[high++] = nums[low++]; &#125; else &#123; ++low; &#125; &#125; return high;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-42.Trapping Rain Water","slug":"Leetcode练习-42-Trapping-Rain-Water","date":"2018-11-01T03:42:36.000Z","updated":"2018-11-01T06:34:28.461Z","comments":true,"path":"2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","excerpt":"","text":"42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 题目连接:https://leetcode-cn.com/problems/trapping-rain-water/description/ 初步思路：木桶的的储水量取决于最短板，那么从左到右扫描，遇到第一个比它高的柱子，然后可以计算这两个柱子之间的储水量。怎么计算中间的储水量：可以观察到底部宽都是1，那就是两个柱子间的矩形面积减去中间柱子的累加之和。这样还有一个问题是，扫描到最高柱子后，就开始“走下坡”了，这时最短板在更高的位置。ok，现在去试验一下，下面列出一坨屎的写法，这是最原始的想法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 42. Trapping Rain Water * * @param height * @return */public int trap(int[] height) &#123; int sum = 0; int low = 0, high = 0; int minIndex = getMaxIndex(height); //正序遍历，计算储水量 while (low &lt; minIndex) &#123; int temp = 0; high = low + 1; while (high &lt; minIndex) &#123; if (height[low] &gt; height[high])&#123; temp += height[high]; ++high; &#125; else break; &#125; sum += height[low] * (high - low -1) - temp; low = high; &#125; //反向遍历 high = height.length-1; while (high &gt;= minIndex) &#123; int temp = 0; low = high - 1; while (low &gt;= minIndex) &#123; if (height[high] &gt; height[low])&#123; temp += height[low]; --low; &#125; else break; &#125; sum += height[high] * (high - low -1) - temp; high = low; &#125; return sum;&#125;/** * @param height * @return */private int getMaxIndex(int[] height) &#123; // TODO Auto-generated method stub int max = -1; int k = 0; for(int i = 0;i&lt;height.length;++i)&#123; if(max&lt;height[i])&#123; max = height[i]; k = i; &#125; &#125; return k;&#125; 按这个思路提交，居然pass了，好吧。当然这一坨shit写法肯定会让很多人放弃阅读了，偷偷看了一下答案，发现答案写的巧妙一些，它是两边向中间收缩，慢慢计算，不过我觉得我的思路也很明了，暂时就不修改了，以下代码来自九章刷题小工具。12345678910111213141516171819202122232425262728293031/** * @param heights: an array of integers * @return: a integer */public int trapRainWater(int[] heights) &#123; // write your code here int left = 0, right = heights.length - 1; int res = 0; if(left &gt;= right) return res; int leftheight = heights[left]; int rightheight = heights[right]; while(left &lt; right) &#123; if(leftheight &lt; rightheight) &#123; left ++; if(leftheight &gt; heights[left]) &#123; res += (leftheight - heights[left]); &#125; else &#123; leftheight = heights[left]; &#125; &#125; else &#123; right --; if(rightheight &gt; heights[right]) &#123; res += (rightheight - heights[right]); &#125; else &#123; rightheight = heights[right]; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-11.Container With Most Water.md","slug":"Leetcode练习-11-Container-With-Most-Water-md","date":"2018-10-31T13:15:15.000Z","updated":"2018-11-01T06:14:02.731Z","comments":true,"path":"2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","link":"","permalink":"http://tiger07706.github.io/2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","excerpt":"","text":"11. Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.Example: Input: [1,8,6,2,5,4,8,3,7]Output: 49 解答：暴力求解，时间复杂度O(n^2),空间复杂度O(1) 1234567891011public int maxArea(int[] height) &#123; int max = -1; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; int high = height[i] &gt; height[j] ? height[j] : height[i]; int temp = (j - i) * high; max = max &gt; temp ? max : temp; &#125; &#125; return max;&#125; 一提交，pass。","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-10-18T03:19:28.000Z","updated":"2018-10-19T09:42:40.015Z","comments":true,"path":"2018/10/18/排序算法/","link":"","permalink":"http://tiger07706.github.io/2018/10/18/排序算法/","excerpt":"","text":"十大基本排序算法汇总时间复杂度和空间复杂度对比 排序算法 时间复杂度（平均） 时间复杂度（最坏） 时间复杂度（最好） 空间复杂度 稳定性 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n^2) O(n) O(n+k) 稳定 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 希尔排序 O(n1.3) O(n^2) O(n) O(1) 不稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 快速排序 O(nlog2n) O(n^2) O(nlog2n) O(nlog2n) 不稳定 1.冒泡排序可能大部分人第一次接触排序，学的都是冒泡排序，不多说，直接贴代码吧。 一个优化的思路：标记位判断是否有序123456789101112public static void BubbleSort(int[] arr) &#123; for (int i = 0, len = arr.length; i &lt; len - 1; i++) &#123; boolean flag = false; // 标记判断是否有序 for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125;&#125; 另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了1234567891011public static void BubbleSort2(int[] arr) &#123; for (int i = 0, len = arr.length, lastPosition = 0; i &lt; len - 1; i = len - lastPosition - 1) &#123; lastPosition = 0; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j]&gt;arr[j + 1]) &#123; swap(arr, j, j + 1); lastPosition = j; &#125; &#125; &#125;&#125; 延伸：鸡尾酒排序鸡尾酒是一种特殊的冒泡排序，先用正向冒泡，把最大的值冒泡到后面，再用反向冒泡把最小值冒泡到数组前面。 参考阅读：https://mp.weixin.qq.com/s/XC85OLOZEUNuV2t6M1I3jg 2.快速排序第二个介绍的是快速排序，因为最近参加过一次面试，被问了快速排序，巴拉巴拉的迅速写了个代码，然而关于基准数的选取没答好，好吧下面简单介绍快排以及它的优化方案。 下图是别人做的一个优化方案对比 优化主要是两个思路：一个是优化选取基准数；一个是优化小数组时选取的排序方法。 选取基准数有两种（或者叫枢轴，可能是普通话不好，我一直喊基准数，/手动狗头）1、随机基准数（略） 2、三数取中法 12","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://tiger07706.github.io/categories/基础算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://tiger07706.github.io/tags/排序算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tiger07706.github.io/tags/数据结构/"}]},{"title":"hexo命令速查（持续补充）","slug":"2018-10-17 hexo命令速查","date":"2018-10-17T05:59:25.000Z","updated":"2018-10-19T03:17:01.195Z","comments":true,"path":"2018/10/17/2018-10-17 hexo命令速查/","link":"","permalink":"http://tiger07706.github.io/2018/10/17/2018-10-17 hexo命令速查/","excerpt":"","text":"写作相关的命令新建一篇文章$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 部署 $ hexo g -d $ hexo d -g","categories":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/tags/hexo/"},{"name":"命令","slug":"命令","permalink":"http://tiger07706.github.io/tags/命令/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-17T01:54:00.613Z","updated":"2018-10-17T01:54:00.614Z","comments":true,"path":"2018/10/17/hello-world/","link":"","permalink":"http://tiger07706.github.io/2018/10/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}