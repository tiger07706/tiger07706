{"meta":{"title":"迷途小学生","subtitle":null,"description":null,"author":"tiger07706","url":"http://tiger07706.github.io"},"pages":[{"title":"about","date":"2018-10-17T09:38:45.000Z","updated":"2018-10-18T01:54:13.962Z","comments":false,"path":"about/index.html","permalink":"http://tiger07706.github.io/about/index.html","excerpt":"","text":"联系方式：694594147@qq.com"},{"title":"books","date":"2018-10-18T02:00:01.000Z","updated":"2018-10-18T02:00:01.641Z","comments":true,"path":"books/index.html","permalink":"http://tiger07706.github.io/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-17T09:27:45.000Z","updated":"2018-10-17T09:45:02.692Z","comments":true,"path":"categories/index.html","permalink":"http://tiger07706.github.io/categories/index.html","excerpt":"","text":""},{"title":"links","date":"2018-10-17T09:38:24.000Z","updated":"2018-10-17T09:38:24.046Z","comments":true,"path":"links/index.html","permalink":"http://tiger07706.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2018-10-18T02:03:28.000Z","updated":"2018-10-18T02:03:28.663Z","comments":true,"path":"repository/index.html","permalink":"http://tiger07706.github.io/repository/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-10-18T01:59:45.000Z","updated":"2018-10-18T01:59:45.093Z","comments":true,"path":"tags/index.html","permalink":"http://tiger07706.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode练习-164. Maximum Gap","slug":"Leetcode练习-164-Maximum-Gap","date":"2018-11-06T06:09:41.000Z","updated":"2018-11-06T07:42:08.844Z","comments":true,"path":"2018/11/06/Leetcode练习-164-Maximum-Gap/","link":"","permalink":"http://tiger07706.github.io/2018/11/06/Leetcode练习-164-Maximum-Gap/","excerpt":"","text":"164. 最大间距给定一个无序的数组，找出数组在排序之后，相邻元素之间最大的差值。如果数组元素个数小于 2，则返回 0。 示例 1输入: [3,6,9,1]输出: 3解释: 排序后的数组是 [1,3,6,9], 其中相邻元素 (3,6) 和 (6,9) 之间都存在最大差值 3。示例 2输入: [10]输出: 0解释: 数组元素个数小于 2，因此返回 0。说明 你可以假设数组中所有元素都是非负整数，且数值在 32 位有符号整数范围内。 请尝试在线性时间复杂度和空间复杂度的条件下解决此问题。 题目链接：https://leetcode-cn.com/problems/maximum-gap/description/ 解答这道题难是难在要求在O(n)的时间复杂度内完成，那么肯定不能用常规的排序方式来实现。折腾了好一会，总算写出了pass的方案，基本思路如下：1、采用桶排序的思想，将N个数据划分成为n个桶：比如题中示例1，[3,6,9,1],所有数据都落在[1,9]区间内，于是将该区间划分成为n个桶(实际写的时候划分成为n+1个桶),分别是：0号桶 [1,3)1号桶 [3,5)2号桶 [5,7)3号桶 [7,9]于是对于每个元素ai与桶坐标的映射关系是这样的，桶坐标 j = (ai-min)/step，其中step是桶的大小，示例1中step=2；2、然后分别计算两个桶之间的距离。3、存储到桶的时候并不需要真正存储所有数据，只需要距离最大值（桶底）和最小值（桶顶）即可，这样存入和读取统数据都可以达到O(1)。最终pass的代码是这样的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public int maximumGap(int[] nums) &#123; if (nums.length &lt; 2) return 0; int max = nums[0]; int min = nums[0]; // 找到最大值和最小值作为桶的区间 for (int i = 1; i &lt; nums.length; ++i) &#123; if (max &lt; nums[i]) max = nums[i]; if (min &gt; nums[i]) min = nums[i]; &#125; if (max == min) return 0; int n = nums.length; double step = (max - min)*0.1 / n; BucketNode[] bucket = new BucketNode[n + 1]; for (int i = 0; i &lt;= n; ++i) &#123; bucket[i] = new BucketNode(); &#125; //放到桶里，桶实际只保存了桶底和桶顶 for (int i = 0; i &lt; n; ++i) &#123; int j = (int) ((nums[i] - min) *0.1/ step); insertNums(bucket[j], nums[i]); &#125; int gap = 0; int lastBucket = bucket[0].max; for (int j = 1; j &lt;= n; ++j) &#123; if (!bucket[j].isEmpty) &#123; int tempGap = bucket[j].min - lastBucket; gap = gap &gt; tempGap ? gap : tempGap; // 桶底元素 lastBucket = bucket[j].max; &#125; &#125; return gap;&#125;private void insertNums(BucketNode bucket, int num) &#123; bucket.isEmpty = false; bucket.max = bucket.max &gt; num ? bucket.max : num; bucket.min = bucket.min &gt; num ? num : bucket.min;&#125;public static class BucketNode &#123; int min = Integer.MAX_VALUE; int max = Integer.MIN_VALUE; boolean isEmpty = true;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-707.Design Linked List","slug":"Leetcode练习-707-Design-Linked-List","date":"2018-11-05T09:13:16.000Z","updated":"2018-11-05T09:26:07.858Z","comments":true,"path":"2018/11/05/Leetcode练习-707-Design-Linked-List/","link":"","permalink":"http://tiger07706.github.io/2018/11/05/Leetcode练习-707-Design-Linked-List/","excerpt":"","text":"707. 设计链表设计链表的实现。您可以选择使用单链表或双链表。单链表中的节点应该具有两个属性：val 和 next。val 是当前节点的值，next 是指向下一个节点的指针/引用。如果要使用双向链表，则还需要一个属性 prev 以指示链表中的上一个节点。假设链表中的所有节点都是 0-index 的。 在链表类中实现这些功能： get(index)：获取链表中第 index 个节点的值。如果索引无效，则返回-1。 addAtHead(val)：在链表的第一个元素之前添加一个值为 val 的节点。插入后，新节点将成为链表的第一个节点。 addAtTail(val)：将值为 val 的节点追加到链表的最后一个元素。 addAtIndex(index,val)：在链表中的第 index 个节点之前添加值为 val 的节点。如果 index 等于链表的长度，则该节点将附加到链表的末尾。如果 index 大于链表长度，则不会插入节点。 deleteAtIndex(index)：如果索引 index 有效，则删除链表中的第 index 个节点。 示例MyLinkedList linkedList = new MyLinkedList();linkedList.addAtHead(1);linkedList.addAtTail(3);linkedList.addAtIndex(1,2); //链表变为1-&gt; 2-&gt; 3linkedList.get(1); //返回2linkedList.deleteAtIndex(1); //现在链表是1-&gt; 3linkedList.get(1); //返回3 题目链接：https://leetcode-cn.com/problems/design-linked-list/description/ 解答链表的基本练习，虽然写的不好，也贴上来吧。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104public class MyLinkedList &#123; private LinkedListNode head; private int len; private static class LinkedListNode &#123; int val; LinkedListNode next; &#125; /** Initialize your data structure here. */ public MyLinkedList() &#123; head = new LinkedListNode(); head.val = -1; head.next = null; len = -1; &#125; public int length() &#123; return len; &#125; /** * Get the value of the index-th node in the linked list. If the index is * invalid, return -1. */ public int get(int index) &#123; if (index &gt; len) return -1; int i = 0; LinkedListNode pList = head.next; while (i &lt; index &amp;&amp; pList != null) &#123; i++; pList = pList.next; &#125; return pList.val; &#125; /** * Add a node of value val before the first element of the linked list. * After the insertion, the new node will be the first node of the linked * list. */ public void addAtHead(int val) &#123; LinkedListNode newNode = new LinkedListNode(); newNode.val = val; newNode.next = head.next; head.next = newNode; ++len; &#125; /** Append a node of value val to the last element of the linked list. */ public void addAtTail(int val) &#123; LinkedListNode pList = head; while (pList.next != null) &#123; pList = pList.next; &#125; LinkedListNode newNode = new LinkedListNode(); newNode.val = val; newNode.next = null; pList.next = newNode; len++; &#125; /** * Add a node of value val before the index-th node in the linked list. If * index equals to the length of linked list, the node will be appended to * the end of linked list. If index is greater than the length, the node * will not be inserted. */ public void addAtIndex(int index, int val) &#123; if (index &gt; len+1) return; int count = -1; LinkedListNode pList = head; while (pList.next != null) &#123; if (count == index - 1) break; count++; pList = pList.next; &#125; LinkedListNode newNode = new LinkedListNode(); newNode.val = val; LinkedListNode temp = pList.next; pList.next = newNode; newNode.next = temp; len++; &#125; /** Delete the index-th node in the linked list, if the index is valid. */ public void deleteAtIndex(int index) &#123; if (index &gt; len) return; int count = -1; LinkedListNode pList = head; while(pList.next!=null)&#123; if (count == index - 1) break; count++; pList = pList.next; &#125; pList.next = pList.next.next; len--; &#125;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-567.Permutation in String","slug":"Leetcode练习-567-Permutation-in-String","date":"2018-11-05T07:15:51.000Z","updated":"2018-11-05T07:47:34.714Z","comments":true,"path":"2018/11/05/Leetcode练习-567-Permutation-in-String/","link":"","permalink":"http://tiger07706.github.io/2018/11/05/Leetcode练习-567-Permutation-in-String/","excerpt":"","text":"567. 字符串的排列给定两个字符串 s1 和 s2，写一个函数来判断 s2 是否包含 s1 的排列。换句话说，第一个字符串的排列之一是第二个字符串的子串。 示例1输入: s1 = “ab” s2 = “eidbaooo”输出: True解释: s2 包含 s1 的排列之一 (“ba”).示例2输入: s1 = “abc” s2 = “bbbca”输出: True 解答1、这是简单的滑窗问题，可以假想一个长度为s1.length的滑窗，从左到右进行扫描；2、为了简化问题，只有遇到滑窗内是累加之和等于s1的累加之和才进下一步的判断；3、题目标明，输入字符只包含小写字母，于是可用长度为26的数组标记是否访问，也不做非法字符判断了。 12345678910111213141516171819202122232425262728293031323334353637383940414243public boolean checkInclusion(String s1, String s2) &#123; if (s2.length() &lt; s1.length()) return false; int target = 0; for (int i = 0; i &lt; s1.length(); ++i) &#123; target += s1.charAt(i); &#125; int slideWidth = s1.length(); int sumWindow = 0; for (int i = 0; i &lt; slideWidth-1; ++i) &#123; sumWindow += s2.charAt(i); &#125; for (int i = slideWidth - 1; i &lt; s2.length(); i++) &#123; sumWindow +=s2.charAt(i); if (sumWindow == target) &#123; // 确认是否对的 if(compareStr(s1, s2.substring(i - slideWidth + 1, i + 1))) return true; sumWindow -= s2.charAt(i - slideWidth + 1); &#125; else &#123; sumWindow -= s2.charAt(i - slideWidth + 1); &#125; &#125; return false;&#125;private boolean compareStr(String s1, String s2) &#123; boolean flag = true; int[] visited = new int[26]; for (int i = 0; i &lt; s1.length(); ++i) &#123; visited[s1.charAt(i) - &apos;a&apos;]++; &#125; for (int i = 0; i &lt; s2.length(); ++i) &#123; visited[s2.charAt(i) - &apos;a&apos;]++; &#125; for (int i = 0; i &lt; 26; i++) &#123; if (visited[i] % 2 != 0) &#123; flag = false; break; &#125; &#125; return flag;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-14.Longest Common Prefix","slug":"Leetcode练习-14-Longest-Common-Prefix","date":"2018-11-05T02:46:49.000Z","updated":"2018-11-05T07:47:21.842Z","comments":true,"path":"2018/11/05/Leetcode练习-14-Longest-Common-Prefix/","link":"","permalink":"http://tiger07706.github.io/2018/11/05/Leetcode练习-14-Longest-Common-Prefix/","excerpt":"","text":"14. 最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 “”。 示例1输入: [“flower”,”flow”,”flight”]输出: “fl”题目链接：https://leetcode.com/problems/longest-common-prefix/description/题目难度：easy 解答直接搜索就可以了。1234567891011121314151617181920212223242526public String longestCommonPrefix(String[] strs) &#123; if (null == strs || strs.length &lt;= 0) &#123; return &quot;&quot;; &#125; if (strs.length == 1) return strs[0]; int len = strs[0].length(); for (int i = 1; i &lt; strs.length; ++i) &#123; int iCount = 0; for (int j = 0; j &lt; strs[i].length() &amp;&amp; j &lt; strs[0].length(); ++j) &#123; if (strs[0].charAt(j) == strs[i].charAt(j)) &#123; iCount++; &#125; else &#123; break; &#125; // 比当前的前缀长，可以不用继续遍历了 if (iCount &gt; len) &#123; break; &#125; &#125; if (len &gt; iCount) &#123; len = iCount; &#125; &#125; return strs[0].substring(0, len);&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-463. Island Perimeter","slug":"Leetcode练习-463-Island-Perimeter","date":"2018-11-02T09:41:59.000Z","updated":"2018-11-05T07:47:19.640Z","comments":true,"path":"2018/11/02/Leetcode练习-463-Island-Perimeter/","link":"","permalink":"http://tiger07706.github.io/2018/11/02/Leetcode练习-463-Island-Perimeter/","excerpt":"","text":"463. 岛屿的周长给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。 示例输入:[[0,1,0,0], [1,1,1,0], [0,1,0,0], [1,1,0,0]] 解释: 它的周长是下面图片中的 16 个黄色的边： 题目链接:https://leetcode-cn.com/problems/island-perimeter/description/ 解答虽然这道题是easy级别的,但是我发现它有个挺有意思的规律，那就是每读到一个标记为1的格子，它贡献的周长的计算应该是： 4-sum(上下左右格子之和) 于是只要把这个矩阵读完就可以了，好吧，我先试验一下：1234567891011121314151617181920public int islandPerimeter(int[][] grid) &#123; int result = 0; for (int i = 0; i &lt; grid.length; i++) &#123; for (int j = 0; j &lt; grid[i].length; j++) &#123; if (grid[i][j] == 1) &#123; int x = 4; if (i - 1 &gt;= 0 &amp;&amp; grid[i - 1][j] == 1) x -= 1; if (i + 1 &lt; grid.length &amp;&amp; grid[i + 1][j] == 1) x -= 1; if (j - 1 &gt;= 0 &amp;&amp; grid[i][j - 1] == 1) x -= 1; if (j + 1 &lt; grid[i].length &amp;&amp; grid[i][j + 1] == 1) x -= 1; result += x; &#125; &#125; &#125; return result;&#125; 提交，pass,一坨屎写法，但是pass，以后再回来看怎么优化吧.","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-746.Min Cost Climbing Stairs","slug":"Leetcode练习-746-Min-Cost-Climbing-Stairs","date":"2018-11-01T09:27:48.000Z","updated":"2018-11-05T07:48:30.717Z","comments":true,"path":"2018/11/01/Leetcode练习-746-Min-Cost-Climbing-Stairs/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-746-Min-Cost-Climbing-Stairs/","excerpt":"","text":"746. 使用最小花费爬楼梯数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 costi。每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。 示例输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]输出: 6解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。 注意：cost 的长度将会在 [2, 1000]。每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。题目链接：https://leetcode-cn.com/problems/min-cost-climbing-stairs/description/ 解答这是经典的动态规划题目，每次动作可以选择爬一个阶梯或者两个阶梯，而总体花费最小的走法应该是（走一步的开销）+（走剩下的路的最小开销） 和（走两步的开销）+（走剩下的路的最小开销）之间的较小值。这样说太费劲了，写成公式是这样的： dp[k] = Math.min(cost[i-1]+dp[k-1],cost[i]+dp[k-2]) 123456789101112131415161718public int minCostClimbingStairs(int[] cost) &#123; // 可以直接到达 if (cost.length &lt;= 1) return 0; int dp0 = 0, dp1 = 0, dp2 = 0; for (int i = 1; i &lt; cost.length; i++) &#123; if (cost[i] == cost[i - 1]) &#123; dp0 = cost[i - 1] + dp1; &#125; else &#123; dp0 = (dp2 + cost[i]) &gt;= (dp1 + cost[i - 1]) ? (dp1 + cost[i - 1]) : (dp2 + cost[i]); &#125; dp1 = dp2; dp2 = dp0; &#125; return dp0;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"},{"name":"动态规划","slug":"动态规划","permalink":"http://tiger07706.github.io/tags/动态规划/"}]},{"title":"Leetcode练习-662.Maximum Width of Binary Tree","slug":"Leetcode练习-662-Maximum-Width-of-Binary-Tree","date":"2018-11-01T06:35:17.000Z","updated":"2018-11-05T07:47:04.457Z","comments":true,"path":"2018/11/01/Leetcode练习-662-Maximum-Width-of-Binary-Tree/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-662-Maximum-Width-of-Binary-Tree/","excerpt":"","text":"662. 二叉树最大宽度给定一个二叉树，编写一个函数来获取这个树的最大宽度。树的宽度是所有层中的最大宽度。这个二叉树与满二叉树（full binary tree）结构相同，但一些节点为空。 每一层的宽度被定义为两个端点（该层最左和最右的非空节点，两端点间的null节点也计入长度）之间的长度。题目链接：https://leetcode-cn.com/problems/maximum-width-of-binary-tree/description/ 解题思路这道题我开始想错了，我开始以为是：一个二叉树的最大宽度应该是左右两颗子树各自的最大宽度之和。然而不是的，看了题目示例，是按照每一层来计算的，如下所示：输入: 1 / \\ 3 2 / 5 输出: 2解释: 最大值出现在树的第 2 层，宽度为 2 (3,2)。并不是我所想的，最大宽度是节点5和节点2的距离。这样有个暴力点的解法，将二叉树按照满二叉树树一样存储到数组里面，就可以计算到每一层的距离了。当然我们不需要真正存储这些节点，只需要计算出它在数组中的位置就可以了。一颗满二叉树第k层有多少个节点：2^(k-1)一颗满二叉树总的节点数：2^k - 1额，背错公式了，关键应该是： 如果满二叉树的某一节点在数组中的坐标为i，那么左右孩子是2i-1和2i 中途偷偷看了答案，发现其中一个答案跟我的思路是一样的，折腾了半天，最后通过的代码是这样的：1234567891011121314151617181920212223242526272829303132public int widthOfBinaryTree(TreeNode root) &#123; int maxWidth = -1; if (null == root) return 0; Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;(); Queue&lt;Integer&gt; indexQueue = new LinkedList&lt;&gt;(); queue.offer(root); indexQueue.offer(1); while (!queue.isEmpty()) &#123; int minIndex = Integer.MAX_VALUE; int maxIndex = -1; int len = queue.size(); for (int i = 0; i &lt; len; ++i) &#123; // 两个队列出队入队要保持一致 TreeNode pNode = queue.poll(); int index = indexQueue.poll(); minIndex = minIndex &gt; index ? index : minIndex; maxIndex = maxIndex &gt; index ? maxIndex : index; if (null != pNode.left) &#123; queue.offer(pNode.left); indexQueue.offer(2 * index - 1); &#125; if (null != pNode.right) &#123; queue.offer(pNode.right); indexQueue.offer(2 * index); &#125; &#125; maxWidth = maxWidth &gt; (maxIndex - minIndex + 1) ? maxWidth : (maxIndex - minIndex + 1); &#125; return maxWidth;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-27.Remove Element","slug":"Leetcode练习-27-Remove-Element","date":"2018-11-01T06:16:25.000Z","updated":"2018-11-05T07:47:23.329Z","comments":true,"path":"2018/11/01/Leetcode练习-27-Remove-Element/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-27-Remove-Element/","excerpt":"","text":"27. 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。题目连接:https://leetcode-cn.com/problems/remove-element/description/ 解答使用快慢指针进行遍历，慢指针跳过等于val的值，提交-&gt;pass，下一题。1234567891011public int removeElement(int[] nums, int val) &#123; int low = 0, high = 0; while (low &lt; nums.length) &#123; if (val != nums[low]) &#123; nums[high++] = nums[low++]; &#125; else &#123; ++low; &#125; &#125; return high;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-42.Trapping Rain Water","slug":"Leetcode练习-42-Trapping-Rain-Water","date":"2018-11-01T03:42:36.000Z","updated":"2018-11-01T06:34:28.461Z","comments":true,"path":"2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","excerpt":"","text":"42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 题目连接:https://leetcode-cn.com/problems/trapping-rain-water/description/ 初步思路：木桶的的储水量取决于最短板，那么从左到右扫描，遇到第一个比它高的柱子，然后可以计算这两个柱子之间的储水量。怎么计算中间的储水量：可以观察到底部宽都是1，那就是两个柱子间的矩形面积减去中间柱子的累加之和。这样还有一个问题是，扫描到最高柱子后，就开始“走下坡”了，这时最短板在更高的位置。ok，现在去试验一下，下面列出一坨屎的写法，这是最原始的想法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 42. Trapping Rain Water * * @param height * @return */public int trap(int[] height) &#123; int sum = 0; int low = 0, high = 0; int minIndex = getMaxIndex(height); //正序遍历，计算储水量 while (low &lt; minIndex) &#123; int temp = 0; high = low + 1; while (high &lt; minIndex) &#123; if (height[low] &gt; height[high])&#123; temp += height[high]; ++high; &#125; else break; &#125; sum += height[low] * (high - low -1) - temp; low = high; &#125; //反向遍历 high = height.length-1; while (high &gt;= minIndex) &#123; int temp = 0; low = high - 1; while (low &gt;= minIndex) &#123; if (height[high] &gt; height[low])&#123; temp += height[low]; --low; &#125; else break; &#125; sum += height[high] * (high - low -1) - temp; high = low; &#125; return sum;&#125;/** * @param height * @return */private int getMaxIndex(int[] height) &#123; // TODO Auto-generated method stub int max = -1; int k = 0; for(int i = 0;i&lt;height.length;++i)&#123; if(max&lt;height[i])&#123; max = height[i]; k = i; &#125; &#125; return k;&#125; 按这个思路提交，居然pass了，好吧。当然这一坨shit写法肯定会让很多人放弃阅读了，偷偷看了一下答案，发现答案写的巧妙一些，它是两边向中间收缩，慢慢计算，不过我觉得我的思路也很明了，暂时就不修改了，以下代码来自九章刷题小工具。12345678910111213141516171819202122232425262728293031/** * @param heights: an array of integers * @return: a integer */public int trapRainWater(int[] heights) &#123; // write your code here int left = 0, right = heights.length - 1; int res = 0; if(left &gt;= right) return res; int leftheight = heights[left]; int rightheight = heights[right]; while(left &lt; right) &#123; if(leftheight &lt; rightheight) &#123; left ++; if(leftheight &gt; heights[left]) &#123; res += (leftheight - heights[left]); &#125; else &#123; leftheight = heights[left]; &#125; &#125; else &#123; right --; if(rightheight &gt; heights[right]) &#123; res += (rightheight - heights[right]); &#125; else &#123; rightheight = heights[right]; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"Leetcode练习-11.Container With Most Water.md","slug":"Leetcode练习-11-Container-With-Most-Water-md","date":"2018-10-31T13:15:15.000Z","updated":"2018-11-05T07:47:26.557Z","comments":true,"path":"2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","link":"","permalink":"http://tiger07706.github.io/2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","excerpt":"","text":"11. 盛最多水的容器给定 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0)。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。说明：你不能倾斜容器，且 n 的值至少为 2。图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。 示例:输入: [1,8,6,2,5,4,8,3,7]输出: 49题目链接：https://leetcode-cn.com/problems/container-with-most-water/description/ 解答暴力求解，时间复杂度O(n^2),空间复杂度O(1) 1234567891011public int maxArea(int[] height) &#123; int max = -1; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; int high = height[i] &gt; height[j] ? height[j] : height[i]; int temp = (j - i) * high; max = max &gt; temp ? max : temp; &#125; &#125; return max;&#125; 一提交，pass。","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-10-18T03:19:28.000Z","updated":"2018-10-19T09:42:40.015Z","comments":true,"path":"2018/10/18/排序算法/","link":"","permalink":"http://tiger07706.github.io/2018/10/18/排序算法/","excerpt":"","text":"十大基本排序算法汇总时间复杂度和空间复杂度对比 排序算法 时间复杂度（平均） 时间复杂度（最坏） 时间复杂度（最好） 空间复杂度 稳定性 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n^2) O(n) O(n+k) 稳定 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 希尔排序 O(n1.3) O(n^2) O(n) O(1) 不稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 快速排序 O(nlog2n) O(n^2) O(nlog2n) O(nlog2n) 不稳定 1.冒泡排序可能大部分人第一次接触排序，学的都是冒泡排序，不多说，直接贴代码吧。 一个优化的思路：标记位判断是否有序123456789101112public static void BubbleSort(int[] arr) &#123; for (int i = 0, len = arr.length; i &lt; len - 1; i++) &#123; boolean flag = false; // 标记判断是否有序 for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125;&#125; 另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了1234567891011public static void BubbleSort2(int[] arr) &#123; for (int i = 0, len = arr.length, lastPosition = 0; i &lt; len - 1; i = len - lastPosition - 1) &#123; lastPosition = 0; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j]&gt;arr[j + 1]) &#123; swap(arr, j, j + 1); lastPosition = j; &#125; &#125; &#125;&#125; 延伸：鸡尾酒排序鸡尾酒是一种特殊的冒泡排序，先用正向冒泡，把最大的值冒泡到后面，再用反向冒泡把最小值冒泡到数组前面。 参考阅读：https://mp.weixin.qq.com/s/XC85OLOZEUNuV2t6M1I3jg 2.快速排序第二个介绍的是快速排序，因为最近参加过一次面试，被问了快速排序，巴拉巴拉的迅速写了个代码，然而关于基准数的选取没答好，好吧下面简单介绍快排以及它的优化方案。 下图是别人做的一个优化方案对比 优化主要是两个思路：一个是优化选取基准数；一个是优化小数组时选取的排序方法。 选取基准数有两种（或者叫枢轴，可能是普通话不好，我一直喊基准数，/手动狗头）1、随机基准数（略） 2、三数取中法 12","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://tiger07706.github.io/categories/基础算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://tiger07706.github.io/tags/排序算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tiger07706.github.io/tags/数据结构/"}]},{"title":"hexo命令速查（持续补充）","slug":"2018-10-17 hexo命令速查","date":"2018-10-17T05:59:25.000Z","updated":"2018-10-19T03:17:01.195Z","comments":true,"path":"2018/10/17/2018-10-17 hexo命令速查/","link":"","permalink":"http://tiger07706.github.io/2018/10/17/2018-10-17 hexo命令速查/","excerpt":"","text":"写作相关的命令新建一篇文章$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 部署 $ hexo g -d $ hexo d -g","categories":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/tags/hexo/"},{"name":"命令","slug":"命令","permalink":"http://tiger07706.github.io/tags/命令/"}]}]}