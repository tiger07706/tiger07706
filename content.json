{"meta":{"title":"迷途小学生","subtitle":null,"description":null,"author":"tiger07706","url":"http://tiger07706.github.io"},"pages":[{"title":"about","date":"2018-10-17T09:38:45.000Z","updated":"2018-10-18T01:54:13.962Z","comments":false,"path":"about/index.html","permalink":"http://tiger07706.github.io/about/index.html","excerpt":"","text":"联系方式：694594147@qq.com"},{"title":"tags","date":"2018-10-18T01:59:45.000Z","updated":"2018-10-18T01:59:45.093Z","comments":true,"path":"tags/index.html","permalink":"http://tiger07706.github.io/tags/index.html","excerpt":"","text":""},{"title":"links","date":"2018-10-17T09:38:24.000Z","updated":"2018-10-17T09:38:24.046Z","comments":true,"path":"links/index.html","permalink":"http://tiger07706.github.io/links/index.html","excerpt":"","text":""},{"title":"repository","date":"2018-10-18T02:03:28.000Z","updated":"2018-10-18T02:03:28.663Z","comments":true,"path":"repository/index.html","permalink":"http://tiger07706.github.io/repository/index.html","excerpt":"","text":""},{"title":"books","date":"2018-10-18T02:00:01.000Z","updated":"2018-10-18T02:00:01.641Z","comments":true,"path":"books/index.html","permalink":"http://tiger07706.github.io/books/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-10-17T09:27:45.000Z","updated":"2018-10-17T09:45:02.692Z","comments":true,"path":"categories/index.html","permalink":"http://tiger07706.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Leetcode练习-42.Trapping Rain Water","slug":"Leetcode练习-42-Trapping-Rain-Water","date":"2018-11-01T03:42:36.000Z","updated":"2018-11-01T06:11:04.236Z","comments":true,"path":"2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-42-Trapping-Rain-Water/","excerpt":"","text":"42. 接雨水给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。示例: 输入: [0,1,0,2,1,0,1,3,2,1,2,1]输出: 6 初步思路：木桶的的储水量取决于最短板，那么从左到右扫描，遇到第一个比它高的柱子，然后可以计算这两个柱子之间的储水量。怎么计算中间的储水量：可以观察到底部宽都是1，那就是两个柱子间的矩形面积减去中间柱子的累加之和。这样还有一个问题是，扫描到最高柱子后，就开始“走下坡”了，这时最短板在更高的位置。ok，现在去试验一下，下面列出一坨屎的写法，这是最原始的想法。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 42. Trapping Rain Water * * @param height * @return */public int trap(int[] height) &#123; int sum = 0; int low = 0, high = 0; int minIndex = getMaxIndex(height); //正序遍历，计算储水量 while (low &lt; minIndex) &#123; int temp = 0; high = low + 1; while (high &lt; minIndex) &#123; if (height[low] &gt; height[high])&#123; temp += height[high]; ++high; &#125; else break; &#125; sum += height[low] * (high - low -1) - temp; low = high; &#125; //反向遍历 high = height.length-1; while (high &gt;= minIndex) &#123; int temp = 0; low = high - 1; while (low &gt;= minIndex) &#123; if (height[high] &gt; height[low])&#123; temp += height[low]; --low; &#125; else break; &#125; sum += height[high] * (high - low -1) - temp; high = low; &#125; return sum;&#125;/** * @param height * @return */private int getMaxIndex(int[] height) &#123; // TODO Auto-generated method stub int max = -1; int k = 0; for(int i = 0;i&lt;height.length;++i)&#123; if(max&lt;height[i])&#123; max = height[i]; k = i; &#125; &#125; return k;&#125; 按这个思路提交，居然pass了，好吧。当然这一坨shit写法肯定会让很多人放弃阅读了，偷偷看了一下答案，发现答案写的巧妙一些，它是两边向中间收缩，慢慢计算，不过我觉得我的思路也很明了，暂时就不修改了，以下代码来自九章刷题小工具。12345678910111213141516171819202122232425262728293031/** * @param heights: an array of integers * @return: a integer */public int trapRainWater(int[] heights) &#123; // write your code here int left = 0, right = heights.length - 1; int res = 0; if(left &gt;= right) return res; int leftheight = heights[left]; int rightheight = heights[right]; while(left &lt; right) &#123; if(leftheight &lt; rightheight) &#123; left ++; if(leftheight &gt; heights[left]) &#123; res += (leftheight - heights[left]); &#125; else &#123; leftheight = heights[left]; &#125; &#125; else &#123; right --; if(rightheight &gt; heights[right]) &#123; res += (rightheight - heights[right]); &#125; else &#123; rightheight = heights[right]; &#125; &#125; &#125; return res;&#125;","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"","slug":"Leetcode练习-27-Remove-Element-md","date":"2018-11-01T03:19:15.325Z","updated":"2018-11-01T03:35:08.068Z","comments":true,"path":"2018/11/01/Leetcode练习-27-Remove-Element-md/","link":"","permalink":"http://tiger07706.github.io/2018/11/01/Leetcode练习-27-Remove-Element-md/","excerpt":"","text":"title: Leetcode练习-27.Remove Element.mddate: 2018-11-01 11:19:15categories: Leetcode练习tags: Leetcode 移除元素给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。题目连接:https://leetcode-cn.com/problems/remove-element/description/ 解答：使用快慢指针进行遍历，慢指针跳过等于val的值，提交-&gt;pass，下一题。 1234567891011public int removeElement(int[] nums, int val) &#123; int low = 0, high = 0; while (low &lt; nums.length) &#123; if (val != nums[low]) &#123; nums[high++] = nums[low++]; &#125; else &#123; ++low; &#125; &#125; return high;&#125;","categories":[],"tags":[]},{"title":"Leetcode练习-11.Container With Most Water.md","slug":"Leetcode练习-11-Container-With-Most-Water-md","date":"2018-10-31T13:15:15.000Z","updated":"2018-11-01T03:35:05.220Z","comments":true,"path":"2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","link":"","permalink":"http://tiger07706.github.io/2018/10/31/Leetcode练习-11-Container-With-Most-Water-md/","excerpt":"","text":"Container With Most WaterGiven n non-negative integers a1, a2, …, an , where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water. Example:Input: [1,8,6,2,5,4,8,3,7]Output: 49 解答：暴力求解，时间复杂度O(n^2),空间复杂度O(1) 1234567891011public int maxArea(int[] height) &#123; int max = -1; for (int i = 0; i &lt; height.length; i++) &#123; for (int j = i + 1; j &lt; height.length; j++) &#123; int high = height[i] &gt; height[j] ? height[j] : height[i]; int temp = (j - i) * high; max = max &gt; temp ? max : temp; &#125; &#125; return max;&#125; 一提交，pass。","categories":[{"name":"Leetcode练习","slug":"Leetcode练习","permalink":"http://tiger07706.github.io/categories/Leetcode练习/"}],"tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"http://tiger07706.github.io/tags/Leetcode/"}]},{"title":"排序算法","slug":"排序算法","date":"2018-10-18T03:19:28.000Z","updated":"2018-10-19T09:42:40.015Z","comments":true,"path":"2018/10/18/排序算法/","link":"","permalink":"http://tiger07706.github.io/2018/10/18/排序算法/","excerpt":"","text":"十大基本排序算法汇总时间复杂度和空间复杂度对比 排序算法 时间复杂度（平均） 时间复杂度（最坏） 时间复杂度（最好） 空间复杂度 稳定性 冒泡排序 O(n^2) O(n^2) O(n) O(1) 稳定 插入排序 O(n^2) O(n^2) O(n) O(1) 稳定 归并排序 O(nlog2n) O(nlog2n) O(nlog2n) O(n) 稳定 计数排序 O(n+k) O(n+k) O(n+k) O(n+k) 稳定 桶排序 O(n+k) O(n^2) O(n) O(n+k) 稳定 基数排序 O(n*k) O(n*k) O(n*k) O(n+k) 稳定 希尔排序 O(n1.3) O(n^2) O(n) O(1) 不稳定 选择排序 O(n^2) O(n^2) O(n^2) O(1) 不稳定 堆排序 O(nlog2n) O(nlog2n) O(nlog2n) O(1) 不稳定 快速排序 O(nlog2n) O(n^2) O(nlog2n) O(nlog2n) 不稳定 1.冒泡排序可能大部分人第一次接触排序，学的都是冒泡排序，不多说，直接贴代码吧。 一个优化的思路：标记位判断是否有序123456789101112public static void BubbleSort(int[] arr) &#123; for (int i = 0, len = arr.length; i &lt; len - 1; i++) &#123; boolean flag = false; // 标记判断是否有序 for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; swap(arr, j, j + 1); flag = true; &#125; &#125; if (!flag) break; &#125;&#125; 另一个优化思路：记录下最后一次交换的位置j，表示j后面的已经排好序了1234567891011public static void BubbleSort2(int[] arr) &#123; for (int i = 0, len = arr.length, lastPosition = 0; i &lt; len - 1; i = len - lastPosition - 1) &#123; lastPosition = 0; for (int j = 0; j &lt; len - i - 1; j++) &#123; if (arr[j]&gt;arr[j + 1]) &#123; swap(arr, j, j + 1); lastPosition = j; &#125; &#125; &#125;&#125; 延伸：鸡尾酒排序鸡尾酒是一种特殊的冒泡排序，先用正向冒泡，把最大的值冒泡到后面，再用反向冒泡把最小值冒泡到数组前面。 参考阅读：https://mp.weixin.qq.com/s/XC85OLOZEUNuV2t6M1I3jg 2.快速排序第二个介绍的是快速排序，因为最近参加过一次面试，被问了快速排序，巴拉巴拉的迅速写了个代码，然而关于基准数的选取没答好，好吧下面简单介绍快排以及它的优化方案。 下图是别人做的一个优化方案对比 优化主要是两个思路：一个是优化选取基准数；一个是优化小数组时选取的排序方法。 选取基准数有两种（或者叫枢轴，可能是普通话不好，我一直喊基准数，/手动狗头）1、随机基准数（略） 2、三数取中法 12","categories":[{"name":"基础算法","slug":"基础算法","permalink":"http://tiger07706.github.io/categories/基础算法/"}],"tags":[{"name":"排序算法","slug":"排序算法","permalink":"http://tiger07706.github.io/tags/排序算法/"},{"name":"数据结构","slug":"数据结构","permalink":"http://tiger07706.github.io/tags/数据结构/"}]},{"title":"hexo命令速查（持续补充）","slug":"2018-10-17 hexo命令速查","date":"2018-10-17T05:59:25.000Z","updated":"2018-10-19T03:17:01.195Z","comments":true,"path":"2018/10/17/2018-10-17 hexo命令速查/","link":"","permalink":"http://tiger07706.github.io/2018/10/17/2018-10-17 hexo命令速查/","excerpt":"","text":"写作相关的命令新建一篇文章$ hexo new [layout] &lt;title&gt; 您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。 布局（Layout）Hexo 有三种默认布局：post、page 和 draft，它们分别对应不同的路径，而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 部署 $ hexo g -d $ hexo d -g","categories":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://tiger07706.github.io/tags/hexo/"},{"name":"命令","slug":"命令","permalink":"http://tiger07706.github.io/tags/命令/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-17T01:54:00.613Z","updated":"2018-10-17T01:54:00.614Z","comments":true,"path":"2018/10/17/hello-world/","link":"","permalink":"http://tiger07706.github.io/2018/10/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}